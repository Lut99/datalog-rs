//  COMMON.rs
//    by Lut99
//
//  Created:
//    03 Dec 2024, 10:47:06
//  Last edited:
//    03 Dec 2024, 11:12:14
//  Auto updated?
//    Yes
//
//  Description:
//!   Defines common code between the two macros.
//

use proc_macro2::{Span, TokenStream as TokenStream2};
use quote::quote_spanned;
use syn::parse::{Parse, ParseStream};
use syn::punctuated::Punctuated;
use syn::spanned::Spanned as _;
use syn::token::{Colon, Comma, Dot, Minus, Paren, PathSep};
use syn::{Attribute, Error, Expr, ExprLit, Ident, Lit, LitStr, Meta, Path, PathArguments, PathSegment, Token, parenthesized};


/***** TYPE ALIASES *****/
/// A rule.
pub type Rule = (Punctuated<Consequent, Comma>, Option<((Colon, Minus), Punctuated<Antecedent, Comma>)>, Dot);

/// A rule's consequence.
pub type Consequent = (Ident, Option<(Paren, Punctuated<Ident, Comma>)>);

/// A rule's antecedent.
pub type Antecedent = (Option<Ident>, Ident, Option<(Paren, Punctuated<Ident, Comma>)>);





/***** ATTRIBUTES *****/
/// Defines the attributes we parse from the toplevel.
pub struct DatalogAttributes {
    /// The initial path to use to refer to the crate.
    pub crate_path: Path,
    /// The string used as `from`.
    pub from: LitStr,
}
impl Parse for DatalogAttributes {
    #[inline]
    fn parse(input: ParseStream) -> syn::Result<Self> {
        // Attempt to parse an attribute thingy first
        let attrs: Vec<Attribute> = Attribute::parse_inner(input)?;

        // Create a sensible default
        let mut segments: Punctuated<PathSegment, PathSep> = Punctuated::new();
        segments.push(PathSegment { ident: Ident::new("datalog", Span::call_site()), arguments: PathArguments::None });
        let mut res: Self =
            Self { crate_path: Path { leading_colon: Some(PathSep::default()), segments }, from: LitStr::new("<auto-generated>", Span::call_site()) };

        // Iterate over the attributes to deviate from the default
        for attr in attrs {
            match attr.meta {
                Meta::Path(p) => {
                    if p.is_ident("crate") {
                        // Change the path to be from within this crate
                        let mut segments: Punctuated<PathSegment, PathSep> = Punctuated::new();
                        segments.push(PathSegment { ident: Ident::new("crate", p.span()), arguments: PathArguments::None });
                        res.crate_path = Path { leading_colon: None, segments };
                    } else {
                        return Err(Error::new(p.span(), "Unknown datalog snippet attribute"));
                    }
                },
                Meta::NameValue(nv) => {
                    if nv.path.is_ident("from") {
                        // Parse the value as a string literal
                        let from: LitStr = if let Expr::Lit(ExprLit { attrs: _, lit: Lit::Str(from) }) = nv.value {
                            from
                        } else {
                            return Err(Error::new(nv.value.span(), "Expected a string literal"));
                        };

                        // Set it
                        res.from = from;
                    } else if nv.path.is_ident("crate") {
                        // Parse the value as a string literal first
                        let from: LitStr = if let Expr::Lit(ExprLit { attrs: _, lit: Lit::Str(from) }) = nv.value {
                            from
                        } else {
                            return Err(Error::new(nv.value.span(), "Expected a string literal"));
                        };

                        // Then parse it as a path segment
                        res.crate_path = match syn::parse_str(&from.value()) {
                            Ok(path) => path,
                            Err(err) => return Err(err),
                        };

                        // Set it
                        res.from = from;
                    } else {
                        return Err(Error::new(nv.path.span(), "Unknown datalog snippet attribute"));
                    }
                },
                Meta::List(l) => return Err(Error::new(l.path.span(), "Unknown datalog snippet attribute")),
            }
        }

        // Done!
        Ok(res)
    }
}





/***** PARSE FUNCTIONS *****/
/// Parses a comma-separated list as long as it's nice.
///
/// # Arguments
/// - `input`: The [`ParseStream`] to parse from.
/// - `what`: Another parser that represents the values in the list.
///
/// # Returns
/// A [`Punctuated`] that contains the parsed elements.
///
/// # Errors
/// This function errors if we failed to parse at all.
pub fn parse_punctuated<T>(input: ParseStream, what: fn(input: ParseStream) -> Result<T, Error>) -> Result<Punctuated<T, Comma>, Error> {
    // See if we can parse a value
    let mut res: Punctuated<T, Comma> = Punctuated::new();
    while let Ok(val) = what(input) {
        res.push_value(val);

        // Attempt to parse an punctuation
        if let Ok(punct) = input.parse::<Comma>() {
            res.push_punct(punct);
        }
    }
    Ok(res)
}

/// Parses a rule.
///
/// # Arguments
/// - `input`: The [`ParseStream`] to parse from.
///
/// # Returns
/// A parsed rule, as two lists of [consequents](parse_consequent()) and
/// [antecedents](parse_antecedent()), and a final [`Dot`].
pub fn parse_rule(input: ParseStream) -> Result<Rule, Error> {
    // Parse the consequences
    let consequences = parse_punctuated(input, parse_consequent)?;
    if consequences.is_empty() {
        return Err(input.error("Expected at least one consequent"));
    }

    // Parse the antecedents, if any
    let antecedents = if let (Ok(colon), Ok(minus)) = (input.parse::<Colon>(), input.parse::<Minus>()) {
        // Parse a punctuated list of antecedents
        let antecedents: Punctuated<(Option<Ident>, Ident, Option<(Paren, Punctuated<Ident, Comma>)>), Comma> =
            parse_punctuated(input, parse_antecedent)?;
        if antecedents.is_empty() {
            return Err(input.error("Expected at least one antecedent"));
        }
        Some(((colon, minus), antecedents))
    } else {
        None
    };

    // Parse the final dot
    let dot: Dot = input.parse()?;

    // Done parsing!
    Ok((consequences, antecedents, dot))
}

/// Parses a consequent.
///
/// # Arguments
/// - `input`: The [`ParseStream`] to parse from.
///
/// # Returns
/// A parsed consequent, as a tuple of an identifier and an optional argument list wrapped in parenthesis.
pub fn parse_consequent(input: ParseStream) -> Result<Consequent, Error> {
    // Parse the first identifier
    let name: Ident = input.parse()?;

    // Parse the parenthesis optionally
    let args: Option<(Paren, Punctuated<Ident, Comma>)> = |input: ParseStream| -> Result<(Paren, Punctuated<Ident, Comma>), Error> {
        let content;
        let paren: Paren = parenthesized!(content in input);
        let args: Punctuated<Ident, Comma> = content.parse_terminated(Ident::parse, Token![,])?;
        Ok((paren, args))
    }(input)
    .ok();

    // OK
    Ok((name, args))
}

/// Parses an antecedent.
///
/// # Arguments
/// - `input`: The [`ParseStream`] to parse from.
///
/// # Returns
/// A parsed consequent, as a tuple of an identifier and an optional argument list wrapped in parenthesis.
pub fn parse_antecedent(input: ParseStream) -> Result<Antecedent, Error> {
    // Parse 'not' first
    let name: Ident = input.parse()?;
    let (not, name): (Option<Ident>, Ident) = if name == "not" {
        // Parse a second ident and swap 'em
        let not: Ident = name;
        let name: Ident = input.parse()?;
        (Some(not), name)
    } else {
        // No not found
        (None, name)
    };

    // Parse the parenthesis optionally
    let args: Option<(Paren, Punctuated<Ident, Comma>)> = |input: ParseStream| -> Result<(Paren, Punctuated<Ident, Comma>), Error> {
        let content;
        let paren: Paren = parenthesized!(content in input);
        let args: Punctuated<Ident, Comma> = content.parse_terminated(Ident::parse, Token![,])?;
        Ok((paren, args))
    }(input)
    .ok();

    // OK
    Ok((not, name, args))
}





/***** SERIALIZATION FUNCTIONS *****/
/// Serializes a given [rule](parse_rule()) into tokens representing a `datalog` `Rule`.
///
/// # Arguments
/// - `crate_path`: A prefix that allows one to change where to get the datalog structs from.
/// - `from_str`: The string that is given as the from string in `Span` creations.
/// - `consequences`: A punctuated list of consequents we parsed from the input.
/// - `antecedents`: An optional arrow with a punctuated list of antecedents we parsed from the
///   input.
///
/// # Returns
/// A [`TokenStream2`] that encodes building the matching struct.
pub fn serialize_rule(
    crate_path: &Path,
    from_str: &LitStr,
    consequences: Punctuated<(Ident, Option<(Paren, Punctuated<Ident, Comma>)>), Comma>,
    antecedents: Option<((Colon, Minus), Punctuated<(Option<Ident>, Ident, Option<(Paren, Punctuated<Ident, Comma>)>), Comma>)>,
) -> TokenStream2 {
    // First, generate consequences
    let consequences_tokens: Vec<TokenStream2> = consequences.into_iter().map(|(name, args)| {
        // Generate the arguments
        let (paren_span, args_tokens): (Option<Span>, TokenStream2) = if let Some((paren, args)) = args {
            // Collect the arguments
            let args: Vec<TokenStream2> = args.into_iter().map(|arg| {
                let sarg: String = arg.to_string();

                // Note it down as a variable if it starts with an uppercase
                if sarg.chars().next().expect("Got empty consequence argument identifier").is_uppercase() {
                    quote_spanned! { arg.span() => #crate_path::ast::AtomArg::Var(#crate_path::ast::Ident { value: #crate_path::ast::Span::new(#from_str, #sarg) }) }
                } else {
                    quote_spanned! { arg.span() => #crate_path::ast::AtomArg::Atom(#crate_path::ast::Ident { value: #crate_path::ast::Span::new(#from_str, #sarg) }) }
                }
            }).collect();

            // Put them in a punctuated list
            let mut args_tokens: TokenStream2 = TokenStream2::new();
            for (i, arg) in args.into_iter().enumerate() {
                if i == 0 {
                    args_tokens.extend(quote_spanned! { arg.span() => punct.push_first(#arg); });
                } else {
                    args_tokens.extend(quote_spanned! { arg.span() => punct.push(#crate_path::ast::Comma{ span: #crate_path::ast::Span::new(#from_str, ",") }, #arg); });
                }
            }
            let args_tokens: TokenStream2 = quote_spanned! { Span::call_site() => { let mut punct = #crate_path::ast::Punctuated::new(); #args_tokens punct } };

            // Serialize it to one set of arguments
            (Some(paren.span.join()), quote_spanned!{ paren.span.join() => Some(#crate_path::ast::AtomArgs {
                paren_tokens: #crate_path::ast::Parens { open: #crate_path::ast::Span::new(#from_str, "("), close: #crate_path::ast::Span::new(#from_str, ")") },
                args: #args_tokens,
            })})
        } else {
            (None, quote_spanned!{ name.span() => None })
        };

        // Generate the consequent atom
        let sname: String = name.to_string();
        quote_spanned! {
            if let Some(paren) = paren_span { name.span().join(paren).unwrap_or_else(|| name.span()) } else { name.span() } =>
            #crate_path::ast::Atom {
                ident: #crate_path::ast::Ident { value: #crate_path::ast::Span::new(#from_str, #sname) },
                args: #args_tokens,
            }
        }
    }).collect();
    // let consequences_tokens: TokenStream2 = quote_spanned! { consequences_tokens.first().expect("Got empty consequence list").span().join(consequences_tokens.last().expect("Got empty consequence list").span()).expect("Got consequences from different files") => ::std::vec![ #(#consequences_tokens),* ] };
    let first_span: Span = consequences_tokens.first().expect("Got empty consequence list").span();
    let mut consequences_tokens_punct: TokenStream2 = TokenStream2::new();
    for (i, cons) in consequences_tokens.into_iter().enumerate() {
        if i == 0 {
            consequences_tokens_punct.extend(quote_spanned! { cons.span() => punct.push_first(#cons); });
        } else {
            consequences_tokens_punct.extend(
                quote_spanned! { cons.span() => punct.push(#crate_path::ast::Comma{ span: #crate_path::ast::Span::new(#from_str, ",") }, #cons); },
            );
        }
    }
    let consequences_tokens: TokenStream2 =
        quote_spanned! { first_span => { let mut punct = #crate_path::ast::Punctuated::new(); #consequences_tokens_punct punct } };

    // Next, generate the antecedents
    let antecedents_tokens: TokenStream2 = if let Some(((colon, _), antecedents)) = antecedents {
        // Generate all the antecedents
        let antecedents: Vec<TokenStream2> = antecedents.into_iter().map(|(not, name, args)| {
            // Generate the arguments
            let (paren_span, args_tokens): (Option<Span>, TokenStream2) = if let Some((paren, args)) = args {
                // Generate the individual arguments
                let args: Vec<TokenStream2> = args.into_iter().map(|arg| {
                    let sarg: String = arg.to_string();

                    // Note it down as a variable if it starts with an uppercase
                    if sarg.chars().next().expect("Got empty antecedent argument identifier").is_uppercase() {
                        quote_spanned! { arg.span() => #crate_path::ast::AtomArg::Var(#crate_path::ast::Ident { value: #crate_path::ast::Span::new(#from_str, #sarg) }) }
                    } else {
                        quote_spanned! { arg.span() => #crate_path::ast::AtomArg::Atom(#crate_path::ast::Ident { value: #crate_path::ast::Span::new(#from_str, #sarg) }) }
                    }
                }).collect();

                // Put them in a punctuated list
                let mut args_tokens: TokenStream2 = TokenStream2::new();
                for (i, arg) in args.into_iter().enumerate() {
                    if i == 0 {
                        args_tokens.extend(quote_spanned! { arg.span() => punct.push_first(#arg); });
                    } else {
                        args_tokens.extend(quote_spanned! { arg.span() => punct.push(#crate_path::ast::Comma{ span: #crate_path::ast::Span::new(#from_str, ",") }, #arg); });
                    }
                }
                let args_tokens: TokenStream2 = quote_spanned! { first_span => { let mut punct = #crate_path::ast::Punctuated::new(); #args_tokens punct } };

                // Serialize them to a single argument list
                (Some(paren.span.join()), quote_spanned!{ paren.span.join() => Some(#crate_path::ast::AtomArgs {
                    paren_tokens: #crate_path::ast::Parens { open: #crate_path::ast::Span::new(#from_str, "("), close: #crate_path::ast::Span::new(#from_str, ")") },
                    args: #args_tokens,
                })})
            } else {
                (None, quote_spanned!{ name.span() => None })
            };

            // Generate the consequent atom
            let sname: String = name.to_string();
            let span: Span = if let Some(paren) = paren_span { name.span().join(paren).unwrap_or_else(|| name.span()) } else { name.span() };
            if not.is_some() {
                quote_spanned! {
                    span =>
                    #crate_path::ast::Literal::NegAtom(#crate_path::ast::NegAtom {
                        not_token: #crate_path::ast::Not { span: #crate_path::ast::Span::new(#from_str, "not") },
                        atom: #crate_path::ast::Atom {
                            ident: #crate_path::ast::Ident { value: #crate_path::ast::Span::new(#from_str, #sname) },
                            args: #args_tokens,
                        },
                    })
                }
            } else {
                quote_spanned! {
                    span =>
                    #crate_path::ast::Literal::Atom(#crate_path::ast::Atom {
                        ident: #crate_path::ast::Ident { value: #crate_path::ast::Span::new(#from_str, #sname) },
                        args: #args_tokens,
                    })
                }
            }
        }).collect();

        // Serialize them to a single buffer
        let mut antecedents_tokens: TokenStream2 = TokenStream2::new();
        for (i, ant) in antecedents.into_iter().enumerate() {
            if i == 0 {
                antecedents_tokens.extend(quote_spanned! { ant.span() => punct.push_first(#ant); });
            } else {
                antecedents_tokens.extend(
                    quote_spanned! { ant.span() => punct.push(#crate_path::ast::Comma{ span: #crate_path::ast::Span::new(#from_str, ",") }, #ant); },
                );
            }
        }
        let antecedents_tokens: TokenStream2 =
            quote_spanned! { first_span => { let mut punct = #crate_path::ast::Punctuated::new(); #antecedents_tokens punct } };

        // Serialize them to a single RuleAntecedents
        // quote_spanned! {
        //     colon.span.join(last_span).expect("Colon and last antecedent are from different files") =>
        //     Some(#crate_path::ast::RuleAntecedents {
        //         arrow_token: #crate_path::ast::Arrow { span: #crate_path::ast::Span::new(#from_str, ":-") },
        //         antecedents: #crate_path::ast::punct![ #antecedents_tokens ],
        //     })
        // }
        quote_spanned! {
            colon.span =>
            Some(#crate_path::ast::RuleAntecedents {
                arrow_token: #crate_path::ast::Arrow { span: #crate_path::ast::Span::new(#from_str, ":-") },
                antecedents: #antecedents_tokens,
            })
        }
    } else {
        quote_spanned! { consequences_tokens.span() => None }
    };

    // Finally, serialize the rule!
    quote_spanned! {
        consequences_tokens.span() =>
        #crate_path::ast::Rule {
            consequences: #consequences_tokens,
            tail: #antecedents_tokens,
            dot: #crate_path::ast::Dot { span: #crate_path::ast::Span::new(#from_str, ".") },
        }
    }
}
